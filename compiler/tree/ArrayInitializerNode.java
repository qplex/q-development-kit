// Stub generated by FactoryMaker

package tree;

import compiler.QType;
import compiler.Signature;
import parser.*;

public class ArrayInitializerNode extends QNode implements QParserTreeConstants {
	public int _elementCount;
	
	public ArrayInitializerNode() {
		super(JJTARRAYINITIALIZER);
	}

	void initialize() {
		_elementCount = getChild(0).jjtGetNumChildren();
		
		QType elementType = getChild(0).getChild(0)._type;
		for (int i=1; i<_elementCount; i++) {
			elementType = commonType(elementType, getChild(0).getChild(i)._type);
			if (elementType == null)
				throw new CompileException("Inconsistent types in initializer", getChild(0).getChild(i));
		}
	
		switch (elementType._kind) {
		case INT:
			_type = QType.INTARRAY;
			break;
		case REAL:
			_type = QType.REALARRAY;
			break;
		case BOOLEAN:
			_type = QType.BOOLEANARRAY;
			break;
		case PMF:
			_type = new QType(PMFARRAY, elementType._qualifier);
			break;
		case INTARRAY:
			_type = QType.INTMATRIX;
			break;
		case REALARRAY:
			_type = QType.REALMATRIX;
			break;
		case BOOLEANARRAY:
			_type = QType.BOOLEANMATRIX;
			break;
		case PMFARRAY:
			_type = new QType(PMFMATRIX, elementType._qualifier);
			break;
		case QType.FUNCTION_KIND:
		case INTERFACE:
			_type = new QType(INTERFACEARRAY, (Signature) null);
			break;
		case INTERFACEARRAY:
			_type = new QType(INTERFACEMATRIX, (Signature) null);
			break;
		default:
			assert(false);
		}
	}	

	private static QType commonType(QType t1, QType t2) {
		if (t1.isAssignableFrom(t2))
			return t1;
		
		if (t2.isAssignableFrom(t1))
			return t2;
		
		return null;
	}
}
