// Generated by FactoryMaker

package tree;

import parser.*;

public class NodeFactory implements QParserTreeConstants {
	public static Node jjtCreate(int id) {
		switch(id) {
		case JJTROOT:
			return new RootNode();
		case JJTBLOCK:
			return new BlockNode();
		case JJTSKIPSTATEMENT:
			return new SkipStatementNode();
		case JJTTOKENSTATEMENT:
			return new TokenStatementNode();
		case JJTFAILSTATEMENT:
			return new FailStatementNode();
		case JJTIFSTATEMENT:
			return new IfStatementNode();
		case JJTWHILESTATEMENT:
			return new WhileStatementNode();
		case JJTFORSTATEMENT:
			return new ForStatementNode();
		case JJTFORPARAMETERS:
			return new ForParametersNode();
		case JJTRETURNSTATEMENT:
			return new ReturnStatementNode();
		case JJTRETURNEXPRESSION:
			return new ReturnExpressionNode();
		case JJTRETURNEXPRESSIONELEMENT:
			return new ReturnExpressionElementNode();
		case JJTINTERFACESTATEMENT:
			return new InterfaceStatementNode();
		case JJTINTERFACEARRAYSTATEMENT:
			return new InterfaceArrayStatementNode();
		case JJTINTERFACEMATRIXSTATEMENT:
			return new InterfaceMatrixStatementNode();
		case JJTASSIGNMENTSTATEMENT:
			return new AssignmentStatementNode();
		case JJTDECLARATIONSTATEMENT:
			return new DeclarationStatementNode();
		case JJTSAMPLINGSTATEMENT:
			return new SamplingStatementNode();
		case JJTFUNCTIONDECLARATIONBODY:
			return new FunctionDeclarationBodyNode();
		case JJTPARAMETERS:
			return new ParametersNode();
		case JJTPARAMETERDECLARATION:
			return new ParameterDeclarationNode();
		case JJTTYPE:
			return new TypeNode();
		case JJTATTRIBUTE:
			return new AttributeNode();
		case JJTNEGATIVE:
			return new NegativeNode();
		case JJTNOT:
			return new NotNode();
		case JJTIDENTIFIERLIST:
			return new IdentifierListNode();
		case JJTEXPRESSIONLIST:
			return new ExpressionListNode();
		case JJTOREXPRESSION:
			return new OrExpressionNode();
		case JJTANDEXPRESSION:
			return new AndExpressionNode();
		case JJTNOTEXPRESSION:
			return new NotExpressionNode();
		case JJTEQUALITYEXPRESSION:
			return new EqualityExpressionNode();
		case JJTRELATIONALEXPRESSION:
			return new RelationalExpressionNode();
		case JJTADDITIVEEXPRESSION:
			return new AdditiveExpressionNode();
		case JJTMULTIPLICATIVEEXPRESSION:
			return new MultiplicativeExpressionNode();
		case JJTNEGATIVEEXPRESSION:
			return new NegativeExpressionNode();
		case JJTATTRIBUTEEXPRESSION:
			return new AttributeExpressionNode();
		case JJTSUFFIXEDEXPRESSION:
			return new SuffixedExpressionNode();
		case JJTLOOKUP:
			return new LookupNode();
		case JJTQUALIFIER:
			return new QualifierNode();
		case JJTCALL:
			return new CallNode();
		case JJTCOMPOUNDQUALIFIER:
			return new CompoundQualifierNode();
		case JJTSIMPLEQUALIFIER:
			return new SimpleQualifierNode();
		case JJTARRAYINITIALIZER:
			return new ArrayInitializerNode();
		case JJTARRAYINITIALIZERLIST:
			return new ArrayInitializerListNode();
		case JJTPMFINITIALIZERLIST:
			return new PmfInitializerListNode();
		case JJTPMFINITIALIZER:
			return new PmfInitializerNode();
		case JJTPMFINITIALIZERGROUP:
			return new PmfInitializerGroupNode();
		case JJTPMFINITIALIZERELEMENT:
			return new PmfInitializerElementNode();
		case JJTCREATEEXPRESSION:
			return new CreateExpressionNode();
		case JJTPRIMARYEXPRESSION:
			return new PrimaryExpressionNode();
		default:
			throw new IllegalArgumentException();
		}
	}
}
