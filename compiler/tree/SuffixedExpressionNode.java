// Stub generated by FactoryMaker

package tree;

import compiler.Engine;
import compiler.QType;
import compiler.Qualifier;
import compiler.Signature;
import compiler.Symbol;
import parser.*;

public class SuffixedExpressionNode extends QNode implements QParserTreeConstants {
	public QType[] _types;

	public SuffixedExpressionNode() {
		super(JJTSUFFIXEDEXPRESSION);
	}

	void initialize() {
		if (children == null)
			return;

		int n = jjtGetNumChildren();
		_types = new QType[n];

		_types[0] = _type = getChild(0)._type;

		for (int i = 1; i < n; i++) {
			QNode child = getChild(i);

			switch (child.getId()) {

			case JJTLOOKUP:
				switch (_type._kind) {
				case INTARRAY:
					_type = QType.INT;
					break;
				case REALARRAY:
					_type = QType.REAL;
					break;
				case PMF:
					if (_type._qualifier == null  || _type._qualifier._category != Qualifier.Category.SIMPLE
							|| _type._qualifier._simpleRVNames.size() > 1)
						throw new CompileException("Cannot extract a scalar probability from a joint or compound pmf", child);
					_type = QType.REAL;
					break;
				case BOOLEANARRAY:
					_type = QType.BOOLEAN;
					break;
				case PMFARRAY:
					_type = new QType(PMF, _type._qualifier);
					break;
				case INTMATRIX:
					_type = QType.INTARRAY;
					break;
				case REALMATRIX:
					_type = QType.REALARRAY;
					break;
				case BOOLEANMATRIX:
					_type = QType.BOOLEANARRAY;
					break;
				case PMFMATRIX:
					_type = new QType(PMFARRAY, _type._qualifier);
					break;
				case INTERFACEARRAY:
					_type = new QType(INTERFACE, _type._signature);
					break;
				case INTERFACEMATRIX:
					_type = new QType(INTERFACEARRAY, _type._signature);
					break;
				default:
					throw new CompileException("Type mismatch", this);
				}
				break;

			case JJTQUALIFIER:
				_type = _type.castTo(new Qualifier((QualifierNode) child));
				if (_type == null)
					throw new CompileException("Invalid Pmf extraction", child);
				break;

			case JJTCALL: {
				switch (_type._kind) {
				case QType.FUNCTION_KIND:
				case INTERFACE:
					break;
				default:
					throw new CompileException("Syntax error", child);
				}

				Signature signature = _type._signature;

				int m = signature._parameterTypes.size();
				int mm = child.jjtGetNumChildren() == 0 ? 0 : child.getChild(0).jjtGetNumChildren();
				if (m != mm)
					throw new CompileException("Expected " + m + " arguments", child);

				if (m > 0) {
					QNode expressionList = child.getChild(0);
					for (int j = 0; j < m; j++) {
						QType t = signature._parameterTypes.get(j);
						QType tt = expressionList.getChild(j)._type;

						if (!t.isAssignableFrom(tt))
							throw new CompileException("Type mismatch", expressionList.getChild(j));
					}
				}

				if (firstToken.kind == MULTINOMIAL) {
					Token token = child.getChild(0).getChild(1).jjtGetFirstToken();
					if (token.kind != NUMBER || token.image.contains("."))
						throw new CompileException("Second argument must be a literal integer", child);
					int k = Integer.parseInt(token.image);
					_type = new QType(PMF, new Qualifier(k));
				} else if (firstToken.kind == MULTIVARIATEHYPERGEOMETRIC) {
						Token token = child.getChild(0).getChild(2).jjtGetFirstToken();
						if (token.kind != NUMBER || token.image.contains("."))
							throw new CompileException("Third argument must be a literal integer", child);
						int k = Integer.parseInt(token.image);
						_type = new QType(PMF, new Qualifier(k));
				} else
					_type = signature._returnType;
			}
			}

			_types[i] = _type;
		}
	}
}
