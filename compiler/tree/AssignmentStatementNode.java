// Stub generated by FactoryMaker

package tree;

import compiler.*;
import parser.*;

public class AssignmentStatementNode extends QNode implements QParserTreeConstants {
	public AssignmentStatementNode() {
		super(JJTASSIGNMENTSTATEMENT);
	}

	void initialize() {
		QNode targetNode = getNode(0);
		QType targetType = targetNode._type;

		// Expression with no assignment?
		if (jjtGetNumChildren() == 1) {
			if (targetType != QType.VOID)
				throw new CompileException("Unassigned expression must be void", targetNode);
			return;
		}

		QNode sourceNode = getNode(2);
		QType sourceType = sourceNode._type;

		if (sourceNode.getId() == JJTCREATEEXPRESSION) {
			_type = sourceNode._type = targetType;
		} else {
			if (!targetType.isAssignableFrom(sourceType))
				throw new CompileException("Type mismatch", sourceNode);
			_type = targetType;
		}

		switch (targetNode.getId()) {
		case JJTPRIMARYEXPRESSION: {
			if (firstToken.kind != IDENTIFIER)
				throw new CompileException("Syntax error", this);

			String targetName = firstToken.image;
			Symbol targetSymbol = Engine._instance._symbolTable.get(targetName);
			if (targetSymbol == null)
				throw new CompileException("Unknown symbol " + targetName, this);

			if (targetSymbol._category != null) {
				switch (targetSymbol._category) {
				case FIXED:
					throw new CompileException("Parameter values are fixed", this);
				case INDEX:
					throw new CompileException("For-loop indexes are fixed", this);
				case SAMPLE:
					throw new CompileException("Sampled values are fixed", this);
				default:
					break;
				}
			}
			break;
		}
		case JJTSUFFIXEDEXPRESSION: {
			int n = targetNode.jjtGetNumChildren();
			QNode finalSuffix = targetNode.getChild(n - 1);
			if (finalSuffix.getId() != JJTLOOKUP)
				throw new CompileException("Syntax error", getToken(1));
			break;
		}
		default:
			throw new CompileException("Syntax error", getToken(1));
		}
	}
}
