.. raw:: latex

    \markboth{}{1.\hskip.5em Introduction}
    \section{Introduction}

Introduction
---------------

Q is a programming language for performing calculations with discrete
probability distributions. This document assumes an understanding of
elementary discrete probability, as well as some experience programming
in Python and in a C-style language such as Java.

Q does not produce an executable. Rather, it produces a C++ extension
module for Python. It is up to Python to decide what is to be
calculated, gather inputs, call Q functions, and present outputs. In
other words, Q is used to create building blocks from which Python code
can build applications that address various problems, including those
related to QPLEX. Familiarity with QPLEX is not required in order to
read this document.

The best way to get a sense of Q is to consider an example. Here is a
complete, but very simple, Q source file:

::

       public Pmf convolution(Pmf f, Pmf g) {
           i ~ f;
           j ~ g;
           return i+j;
       }

Although the notation suggests simulation, this Q code actually
describes an entirely deterministic operation.

The first line declares that ``convolution`` is a function that takes
two arguments, of type ``Pmf`` and named ``f`` and ``g``, and returns a
value of type ``Pmf``. (If the function were generating a random sample
of ``i+j``, it would return a value of type ``int``.)

The body of the function (the remainder of the source, enclosed in
braces) declares that this function constructs and returns the pmf of a
random variable that would be generated by sampling ``i`` from ``f``,
then ``j`` from ``g``, and finally adding ``i+j``. It is up to the Q
compiler to determine how to perform this calculation. The details are
hidden from the Q programmer. This makes Q code easier to write and to
read, and allows for the possibility of implementing different
calculations in the future.

Of course, Q is not limited to computing pmfs of sums of independent
random variables. It can compute the joint pmf of any number of
algorithmically-specified functions of random variables of known pmfs.


Getting started with Q
-------------------------

First, make sure the following is installed on your computer:

-  Python 3
-  Java runtime (to execute the Q compiler)
-  C compiler (to build the extension module)
-  Setuptools (Python package) (to build the extension module)

**Step 1.** Create a temporary directory (aka folder).

**Step 2.** Save the five-line convolution program at the top of this
document as ``Convolution.q``.

**Step 3.** Copy the following files from the Q distribution zipfile to
this directory: ``QCompiler.jar``, ``qcompile.py``.

**Step 4.** From OS command prompt, enter the following:

::

       python3 qcompile.py qtest Convolution.q 

**Step 5.** Now enter Python and execute the following:

::

       import qtest
       engine = qtest.Convolution()
       p1 = {0:0.1, 1:0.9}
       p2 = {1:0.5, 2:0.5}
       print(engine.convolution(p1, p2))

You will receive the following output:

::

       {1:0.05,2:0.5,3:0.45}

Congratulations. You have now written and executed a Q program!


Key features of Q
--------------------

Two features set Q apart from other programming languages: Pmf objects
and sampling functions. This section provides a high-level overview.
Details may be found in the Technical Reference (Section 4, below).

Pmfs
~~~~~~~~

Q natively supports three kinds of pmf objects: Simple, Joint and
Compound.

| A **simple pmf** stores a distribution over a finite set of
  nonnegative integers.
| Its type is most commonly expressed as Pmf. Its value can be created
  in a number of ways:

-  By calling a sampling function.
-  By calling a built-in function (such as ``bernoulli`` or
   ``binomial``).
-  By specifying a literal value in an initializer (see Section 4.4.2).
-  By passing a value from Python.

A **joint pmf** stores a distribution of two or more random variables.
Its type is most commonly expressed as ``Pmf{A,B,C}`` where ``A``,
``B``, ``C`` are the names of the random variables. (If names are not
needed, they may be replaced with the wildcard symbol ``?``) Its value
can be created in a number of ways:

-  By calling a sampling function.
-  By calling a built-in function (such as ``multinomial``).
-  By specifying a literal value in an initializer.
-  By passing a value from Python.

If p is a pmf of type ``Pmf{A,B,C}`` then ``p{A}`` extracts the marginal
distribution of ``A`` from ``p``. Likewise, ``p{B,C|A=2}`` expresses the
conditional joint distribution of ``B`` and ``C`` given ``A=2``. Note
that these are extractions, not calculations because p is stored
internally as a marginal and a list of conditional distributions. (The
marginal of ``B`` or ``C`` cannot be obtained by extraction, although it
can be calculated using a trivial sampling function.)

A **compound pmf** holds a collection of two or more simple and/or joint
pmfs. Its purpose is to allow a sampling function to create more than
one distribution. Its type is expressed in the form
``Pmf{(A,B,C),(X)}``. The pmf components of this compound pmf are
extracted by ``p{A,B,C}`` or ``p{X}``.

Sampling functions
~~~~~~~~~~~~~~~~~~~~~~

A sampling function constructs a pmf from a description of an experiment
that would produce the desired pmf. A sampling function is distinguished
from a regular function by the presence of the sampling operator
(``~``). If its body contains a sampling operator, then it is a sampling
function. If its body does not contain a sampling operator, then it is a
regular function.

Because a sampling function creates a pmf, its return type is
necessarily a Pmf. The return statements in a sampling function
contribute to this pmf and terminate a sampling branch of the
experiment, but do not terminate execution of the function.

We have already seen an example in Section 1.
Here is an even more elementary example.

Suppose we flip a biased coin with probability of heads p, and then flip
a second biased coin with probability of heads q. We seek the pmf of the
total number of heads.

This is accomplished by the following sampling function:

::

       public Pmf f(real p real q) {
           i ~ bernoulli(p);
           j ~ bernoulli(q);
           return i+j;
       }

It describes the desired pmf as one that would be obtained if we
generated two independent Bernoulli random variables, and tabulated the
frequencies of their sum.

Alternatively, if we are willing to work out the details, we might write
a regular function, like this:

::

       public Pmf g(real p real q) {
           return { 0:p*p, 1:1-p*p-q*q, 2:q*q };
       }

But this quickly becomes unworkable as the complexity of the
calculations increases. The calculations required by QPLEX are quite
complex, and they are more naturally expressed using sampling functions.
Now, you are probably wondering, but how does a sampling function
calculation actually work? Essentially, it enumerates all the outcomes
in the sample space, and sums the probabilities of outcomes that yield
each output value. Here is pseudo-code for the two-coin example above:

::

       a = empty pmf
       bernoulli_p = bernoulli(p)
       bernoulli_q = bernoulli(q)

       for i = 0 to 1 
            prob_i = bernoulli_p[i]    

           for j = 0 to 1
                prob_j = bernoulli_q[j]
               
               k = i + j
               prob_k = prob_i * prob_j    
               a[k] += prob_k

       return a

Thus, the sampling operator is revealed to be a high-level expression of
a loop, to be iterated over the support of a given pmf.

If you wish to go into more detail, you can examine the C++ file
generated by the Q compiler. It’s a bit verbose, but all of the details
are spelled out. Also, see Section 7.

But wait, there’s more!

The ``skip`` statement causes a branch of the sample enumeration to be
abandoned. (Rather like the continue statement in a for-loop.) Now the
recorded outcome probabilities will not sum to one, and they represent
the relative frequencies of outcomes that were not skipped. After
normalizing these probabilities, we obtain the conditional pmf for
un-skipped outcomes. This example will generate the conditional pmf of a
binomial restricted to its tail:

::

       public Pmf h(real p, int k) {
           i ~ binomial(n, p);
           if (i < k) {
               skip;
           } else {
               return i;
           }
       }

And sampling functions can generate a joint distributions of many random
variables. Or many distributions from one experiment.

The following code generates a compound pmf that contains the marginals
of a given joint pmf of two random variables:

::

       public Pmf{(I),(J)} m(Pmf{I, J} givenPmf) {
           i, j ~ givenPmf;
           return (i), (j);
       }

Here ``Pmf{(I),(J)}`` represents the return type (a compound pmf), and
``Pmf{I, J}`` represents the parameter type (a joint pmf). (This
notation was introduced in Section 3.1.)


Q technical reference
------------------------

Language characteristics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Q is a C-style language. Some familiar characteristics:

-  White space (spaces, tabs and line breaks) is ignored.
-  Single-line comments start with // and extend to the end of the line.
-  Multi-line comments start with /\* and extend to \*/.
-  Code is case-sensitive.
-  Statements end with a semicolon.
-  Blocks are enclosed in braces.

Q is not an object-oriented language (although it incorporates compound
value types that we will call objects).

Q is strongly and statically typed (like C and Java, unlike Python).

Identifiers
~~~~~~~~~~~~~~~

Identifiers are names defined in Q source. There are three kinds of
identifiers:

**Standard identifiers** represent variables, functions or interfaces.
They consist of letters and digits, and must start with a lowercase
letter. Underscores are not permitted. Examples: ``numberOfServers``, ``x0``.

**Token identifiers** consist of uppercase letters, digits, and
underscores, must start with a letter or underscore, and must be
contained by single quotes: Examples: ``FIRST_CLASS``, ``ECONOMY``, ``_``.

**Random variable identifiers** consist of uppercase letters, digits,
and underscores and must start with a letter or underscore. They appear
in braces next to pmf types, names, and functions. Like this:
``Pmf{Z, L}``. Examples: ``Z``, ``L``, ``A_VERY_LONG_NAME``,
``NUMBER_9``, ``_``.

Types
~~~~~~~~~

``int`` represents a 32-bit signed integer

``real`` represents a 64-bit double-precision real number

``boolean`` represents the values ``true`` or ``false``.

``void`` is a degenerate type that contains nothing. It is used to
specify the return type of a function that does not return a value.

``token`` is a type whose value is an integer constant.

``interface`` is a type whose value is a function. For more on
interfaces, see Section 4.8.8.

Q also supports the following object types: ``IntArray``, ``RealArray``,
``BooleanArray``, ``IntMatrix``, ``RealMatrix``, ``BooleanMatrix``,
``Pmf``, ``PmfArray``, ``PmfMatrix``, ``InterfaceArray`` and
``InterfaceMatrix``.

You cannot create custom object types in Q source.

Pmf objects are immutable. But array and matrix types are not. If you
assign the same array or matrix value to two variables, and you change
one, the other changes as well. Example:

::

       IntArray a1 = createIntArray(10);
       IntArray a2 = a1; // a1 and a2 point to the same array
       a1[0] = 42;       // Now a2[0] equals 42 as well.  

Values
~~~~~~~~~~~

Literals
^^^^^^^^^^^^^^^^

``int`` literals are what you expect: ``0``, ``-1``, ``17``, ``2023``.

``real`` literals include a decimal point and may include a power of 10.
Examples: ``0.``, ``-1.0``, ``3.1415``, ``9.1e-31``.

``boolean`` literals are ``true`` and ``false``.

Initializers
^^^^^^^^^^^^^

Initializers allow you to specify an object value in Q source.
Initializers may appear only on the right-hand-side of an assignment
statement or in a return statement.

Array initializers are comma-separated lists enclosed in square
brackets. Example: ``[1,2,3]``.

Matrix initializers are arrays of arrays. Example:
``[[1,2,3], [4,5,6]]``. Note that the rows of a matrix need not have the
same length. Example: ``[[1],[1,2],[1,2,3]]``.

Pmf initializers are comma-separated value:probability pairs, enclosed
in braces. Example: ``{1:0.1, 2:0.2, 3:0.3, 26:0.4}``.

A joint pmf initializer contains a tuple of sample values instead.
Example: ``{(0,0):0.1, (1,1):0.2, (2,0):0.3, (2,1):0.4}``.

A compound pmf initializer is specified as a tuple of simple or joint
pmfs. Example: ``({(0,0):0.1, (1,1):0.9}, {1:0.3, 2:0.7})``.

In pmf initializers, samples are not required to be consecutive or to
appear in any particular sequence. The probabilities of duplicate sample
values are summed. (This differs from Python, where duplicate entries in
a dictionary overwrite earlier values.) And probabilities are normalized
so they sum to one. If the probability in a value:probability pair is
zero or negative, the pair is ignored. If the probability in a
value:probability pair is greater than one, it is replaced by one.

Default values
^^^^^^^^^^^^^^^^^^^^

A variable declared without an assignment will be given a default value.
Every type has an associated default value:

======================== =============================
Type                     Default value
======================== =============================
``int``                  ``0``
``real``                 ``0.1``
``boolean``              ``false``
``Pmf``                  ``{0:1.0}``
``Pmf{?,?}``             ``{(0,0):1.0}``
``IntArray``             ``[0]``
``RealArray``            ``[0.0]``
``BooleanArray``         ``[false]``
``PmfArray``             ``[{0:1.0}]``
``PmfArray{?,?}``        ``[{(0,0):1.0}]``
``IntMatrix``            ``[[0]]``
``RealMatrix``           ``[[0.0]]``
``BooleanMatrix``        ``[[false]]``
``PmfMatrix``            ``[[{0:1.0}]]``
``PmfMatrix{?,?}``       ``[[{(0,0):1.0}]]``
``Pmf{(A,B),(C)}``       ``({(0,0):1.0},{0:1.0})``
``PmfArray{(A,B),(C)}``  ``[({(0,0):1.0},{0:1.0})]``
``PmfMatrix{(A,B),(C)}`` ``[[({(0,0):1.0},{0:1.0})]]``
======================== =============================

Operators
~~~~~~~~~~~

Q supports the usual arithmetic binary operators ``+``, ``–``, ``*``, /
as well as the negative unary operator ``–``. A slash ( ``/`` ) denotes
real division, even when the operands are integers.

Q supports the logical operators ``&&`` and ``||`` and the “not” unary
operator ``!``.

Q supports the relational operators ``==``, ``!=``, ``<``, ``<=``,
``>``, ``>=``.

An array element can be referenced by placing an element index in square
brackets:

::

       int k = a[i];

A matrix reference is simply two array lookups:

::

       int k = m[i][j];

A matrix lookup with a single index references a row of the matrix as an
array.

::

       IntArray a = m[i];

References may also appear to the left of the equal sign:

::

       a[i] = k;

       m[i][j] = k;

       m[i] = a;

In the last example (above), the i-th row of a matrix is replaced with a
given array. The rows of a matrix are not required to be of equal
length. So you might replace a row of length 4 with a row of length 2.

A probability in a simple Pmf can be retrieved using square brackets:

::

       real x = p[z];

An element of an array or matrix can be modified by placing the lookup
to the left of the equal sign:

::

       a[i] = k;

The probabilities in a pmf cannot be modified.

Attributes
~~~~~~~~~~~~~

An attribute is a property of an object. Q supports three attributes:

-  a.length holds the size of an array or number of rows in a matrix.
-  p.minValue holds the smallest sample value of a simple pmf.
-  p.maxValue holds the largest sample value of a simple pmf.

Statements
~~~~~~~~~~~~~~~

Declaration statement
^^^^^^^^^^^^^^^^^^^^^^^^^

A variable declaration creates a variable of a specified type. Example:

::

       int i;

A variable is local if it is declared inside a function. Otherwise, it
is global.

Place public at the start of a global variable declaration to indicate
that this variable is to be accessible from Python. Example:

::

       public int i;

Unlike C, Java and Python, a declaration inside a block cannot hide a
declaration of the same name outside the block. The following will
result in a duplicate symbol definition compilation error. Examples:

::

       int i;

       void f() {
           int i;
           …

or

::

       void f(int i) {
           int i;
           …

or

::

       void f() {
           int i;
           if (…) {
               int i;
           …

Assignment statement
^^^^^^^^^^^^^^^^^^^^^^^^^^^

An assignment statement stores a value in the location specified by a
variable name or array element. Example:

::

       i = 42;

Combined declaration and assignment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For local variables, you can combine declaration and assignment, like
this:

::

       int i = 42;

Token declaration
^^^^^^^^^^^^^^^^^^^^^^^

Tokens are assigned a nonnegative integer value when declared:

::

       token 'FIRST_CLASS' = 1;

Token declarations must be global.

Sampling statement
^^^^^^^^^^^^^^^^^^^^^^^^

A sampling statement assigns a sample value to one or more variables,
and repeats for every possible sample value. Examples:

::

       i ~ p1;
       i, j ~ p2;

The variables to the left of the sampling operator (``~``) are
necessarily of type integer. Furthermore, they are of a special integer
type that cannot be modified (in C, const int). For these reasons, it is
not permitted to place ``int`` at the start of a sampling statement.

Void statement
^^^^^^^^^^^^^^^^^^^^^

This statement contains a call to a function that returns no value.

For-loop
^^^^^^^^^^^^^^

In Q, the for-loop takes the following form:

::

       for (i = n to m) {…}    

where ``n`` and ``m`` are integer expressions. The iteration is from
``n`` to ``m`` inclusive.

While-loop
^^^^^^^^^^^^^^^^

A while-loop repeats so long as a boolean expression is true:

::

       while (_boolean expression_) {…}

If / else
^^^^^^^^^^^^^^^

This statement takes three forms

::

       if (_boolean expression_) { … }

       if (_boolean expression_) { … } else { … }

       if (_boolean expression_) { … } else if …

Fail
^^^^^^^^^^^^^

This statement generates a runtime error. Example:

::

       fail "numberOfStations must be positive";

This is the only place in Q where a literal string may appear.

Skip
^^^^^^^^^^^

The skip statement may appear in a sampling function. See discussion in
Section 3.2.

Return
^^^^^^^^^^^^^

For non-sampling functions, this has the conventional meaning of
returning a value to the caller upon completion of the function.

For sampling functions, this statement contributes a sample to the pmf
being created. The return value(s) must be nonnegative integers,
possibly enclosed in parentheses to match the configurations of the
target Pmf. Here’s the general form.

Simple pmf:

::

       Pmf f() {
           …
           return a;
       }   

Joint pmf:

::

       Pmf{A,B} f() {
           …
           return a, b;
       }
               

Compound pmf:

::

       Pmf{(A,B),(C)} f() {
           …
           return (a,b),(c);
       }

Built-in functions
~~~~~~~~~~~~~~~~~~~~~~

Arithmetic functions
^^^^^^^^^^^^^^^^^^^^^^^^^^

+-----------------------------+------------------------------------------+
| Signature                   | Return value                             |
+=============================+==========================================+
| ``int min(int a, int b)``   | The lesser of integers ``a`` and ``b``   |
+-----------------------------+------------------------------------------+
| ``int max(int a, int b)``   | The greater of integers ``a`` and ``b``  |
+-----------------------------+------------------------------------------+
| ``int floor(real x)``       | The greatest integer less than or equal  |
|                             | to ``x``                                 |
+-----------------------------+------------------------------------------+
| ``int ceiling(real x)``     | The least integer greater than or equal  |
|                             | to ``x``                                 |
+-----------------------------+------------------------------------------+
| ``real sqrt(real x)``       | The square root of ``x``                 |
+-----------------------------+------------------------------------------+
| ``real log(real x)``        | The natural logarithm of ``x``           |
+-----------------------------+------------------------------------------+
| ``real exp(real x)``        | The exponential of ``x``                 |
+-----------------------------+------------------------------------------+
| ``real pow(real x, real y)``| ``x`` raised to the ``y`` power          |
+-----------------------------+------------------------------------------+
| ``int computeLeftTail``     | The least ``i`` s.t.                     |
| ``(Pmf pmf, real e)``       | ``pmf``\ {<=\ ``i``} >= ``e``            |
+-----------------------------+------------------------------------------+
| ``int computeRightTail``    | The greatest ``i`` s.t.                  |
| ``(Pmf pmf, real e)``       | ``pmf``\ {>=\ ``i``} >= ``e``            |
+-----------------------------+------------------------------------------+

Create functions
^^^^^^^^^^^^^^^^^^^^^^^

These functions create new instances of arrays and matrices, filled with
the default value of their respective element types (See Section 4.4.3.)

::

       IntArray createIntArray(int)
       
       RealArray createRealArray(int)

       BooleanArray createBooleanArray(int)

       PmfArray createPmfArray(int)
       
       IntMatrix createIntMatrix(int, int)

       RealMatrix createRealMatrix(int, int)

       BooleanMatrix createBooleanMatrix(int, int)

       PmfMatrix createPmfMatrix(int, int)

       InterfaceArray createInterfaceArray(int)

       InterfaceMatrix createInterfaceMatrix(int, int)

The functions ``createPmfArray``, ``createPmfMatrix``,
``createInterfaceArray`` and ``createInterfaceMatrix`` return special
values of indeterminate type. A type is determined when the returned
value is assigned to a variable. Therefore, calls to these functions may
appear only on the right-hand-side of an assignment statement. Example:

::

       PmfArray{A,B} pmfArray = createPmfArray(42);

After executing this statement, The variable ``pmfArray`` will contain
an array of 42 elements of type ``Pmf{A,B}``, each of value
``{(0,0):1.0}``.

Pmf statistical functions
^^^^^^^^^^^^^^^^^^^^^^^^^^

``Pmf bernoulli(real p)``

Returns a Bernoulli pmf with parameter p. That is, ``{0:1-p, 1:p}``.

``Pmf binomial(int n, real p)``

Returns a binomial pmf with parameters:

-  ``n`` = the number of trials.
-  ``p`` = the probability of success on each trial.

``Pmf{?,?,...} multinomial(int n, int k, Pmf p)``

Returns a multinomial pmf with parameters:

-  ``n`` = the number of trials.
-  ``k`` = the number of possible outcomes for each trial.
-  ``p`` = the pmf of outcomes.
-  ``k`` must be an integer literal.
-  The number of question marks in the returned pmf configuration must
   equal ``k``.
-  The support of ``p`` is restricted to of 0,1,…,\ ``k``-1.

``Pmf hypergeometric(int bigN, int bigK, int n)``

Returns a hypergeometric pmf with parameters:

-  ``bigN`` = the original population size.
-  ``bigK`` = the number of marked items in the original population.
-  ``n`` = number to pick (without replacement).

``Pmf{?,?,...} multivariateHypergeometric(int bigN, int n, int d, IntArray b)``

Returns a multivariate hypergeometric pmf with parameters:

-  ``bigN`` = the original population size
-  ``n`` = number to pick (without replacement)
-  ``d`` = number of kinds of items
-  ``b`` = array of original counts by kind.
-  ``d`` must be an integer literal
-  The number of question marks in the returned pmf configuration must
   equal ``d``
-  The length of array ``b`` must equal ``d``
-  The sum of elements in ``b`` must equal ``N``.

``Pmf createPmfFromRealArray(RealArray a)``

Returns a pmf with probabilities listed in ``a``. That is:

-  ``a[0]`` will be the probability of 0,
-  ``a[1]`` will be the probability of 1,

and so on.

``boolean isSamePmfInstance(Pmf a, Pmf b)``

Returns whether two pmfs occupy the same memory address. Used to
determine whether a public Pmf variable has been changed from Python.

Random numbers
^^^^^^^^^^^^^^^^^^^^

``int randomInt(int n)``

Generates a random integer between 0 and n-1 (inclusive).

``real x = randomReal()``

Generates a random real between 0 and 1.

Branch probability
^^^^^^^^^^^^^^^^^^^^^^^^

``real branchProbability()``

Used in a sampling function to retrieve the probability of reaching the
statement in which the call appears.

Declared functions
^^^^^^^^^^^^^^^^^^^^^^^^

A function declaration consists of a return type (possibly void), the
function name, and a list of arguments (possibly empty). Example:

::

       int sum(int a, int b) { 
           return a + b; 
       }

If the sampling operator (``~``) appears in the body of a declared
function, it is considered to be a sampling function. See Section 3.2.

Constructor
^^^^^^^^^^^^^^^^^

The optional declared function ``init`` is called upon startup. It can
be used to initialize global variables and takes any number of
parameters (including none).

Interfaces
^^^^^^^^^^^^^^^^

An interface declaration resembles a function declaration without an
implementation. Example:

::

       interface int h(Pmf p);

Interfaces (like functions) must be global.

In order to specify the implementation of an interface, simply assign a
function of compatible signature to it:

::

       h = f;

An interface is called the same way a function is called:

::

       int i = h(p);  

If the interface has not been assigned an implementation, the call
generates a runtime error.

An interfaceArray declaration takes the same form as an interface
declaration:

::

       interfaceArray int ha(Pmf p);

You can then use an initializer to assign it a value:

::

       ha = [f,f,f];

If the size of the array is not known at compile time, you can use
createInterfaceArray to create an instance.

The declaration of an interfaceMatrix follows the same format.

Additional rules
~~~~~~~~~~~~~~~~~~~~

**Rule 1**. The source code for an extension module must appear in a
single text file. Why? Because multiple source files are harder to
implement. We might add this capability later.

**Rule 2**. You cannot use a symbol until after you have declared it.
Why? Because two-pass compilers are harder to implement. C carries the
same restriction. We might add this capability later.

**Rule 3**. Functions and interfaces must have global scope. Why?
Because Q is not object-oriented. C carries the same restriction.

**Rule 4**. Global variables may not be assigned initial values upon
declaration.

(legal)

::

       public int NumberOfServers;

(illegal)

::

       public int NumberOfServers = 42;

Why? Because the sequence in which initial values are assigned could be
ambiguous. However, initial values may be assigned by the constructor.

**Rule 5**. The value of function parameters, samples and for-loop
indexes must be assigned upon declaration, and cannot later be changed.

(illegal)

::

       void f(int i) {
           i = 42;
       }

(illegal)

::

       for (i = 0 to 10) {
           i = -1;
       }

(illegal)

::

       int i = 0;
       ...
       i ~ p;

Why? Mostly, it’s a matter of style.

**Rule 6**. If a block contains a sampling statement, then the only way
to leave the block must be through a return or skip statement.

(illegal)

::

       int i;      
       if (b == 1) { 
           i ~ f;
       } else {
           i ~ g;  
       }
       return i + 1;

(legal)

::

       if (b == 1) { 
           i ~ f;
           return i + 1;
       } else {
           i ~ g;  
           return i + 1;
       }

Why? Because sampling statements are implemented as for-loops that
iterate through the sample values of a pmf. Such loops cannot extend
beyond the block in which they were created.

**Rule 7**. Blocks must appear in function declarations, for-loops and
if-else statements, and may not appear elsewhere.

(illegal)

::

       if (i < 0)
           return 0;

(legal)

::

       if (i < 0) {
           return 0;
       }

Why? Mostly, it’s a matter of style.


Accessing Q from Python
--------------------------

Each Q source file defines a Python class that we call an engine. One or
more engines may be packaged into a Python extension module when running
the Q compiler.

Engine names must be CamelCase. Module names must be lower case, with
underscores allowed. These rules are consistent with Python
recommendations, but for Q, they are mandatory.

In the discussion that follows, we will use ``qdemo`` as the module
name, and ``Engine`` as the engine name.

To access the module from Python,

::

       import qdemo

To create an engine instance,

::

       engine = qdemo.Engine()

This constructor can take parameters if an ``init`` function was
specified in the Q code.

Public variables of the engine appear as members of the Python object
engine:

::

       engine.x = 42
       print(engine.x)

Likewise, public tokens:

::

       token = engine.MY_TOKEN

Public functions of the engine may be similarly invoked:

::

       sum = engine.sum(2, 2)

Q identifiers will be converted to accommodate Python naming
conventions. For example, a Q variable called ``myVariable`` will appear
in Python as ``my_variable``.

To assign a function to an interface, enclose the (Python) name of the
function in quotes:

::

       engine.h = 'my_function'

You cannot call an interface directly from Python.

Note that you can copy an array or matrix from engine to Python, or from
Python to engine, but you cannot change engine array or matrix elements
individually from Python:

::

       engine.a[3] = 42   # ERROR

Here’s why: The array is copied from engine to Python, and an element of
the Python array is modified, but then the Python array is discarded.
The engine array remains unchanged. No error message will be generated.

In order to track memory use, the following read-only engine attributes
are provided: engine.current_memory_use and engine.peak_memory_use.
Memory use is measured in bytes.

Pmfs are constructed in Python exactly as in Q - see Section 4.4.2.
Suppose the engine’s Q code contains the following:

::

       public Pmf p;
       public Pmf{?,?} q;

Then values can be assigned from Python according to:

::

       engine.p = {1:0.1, 2:0.2, 3:0.3, 4:0.4}
       engine.q = {(1,7):0.1, (2,3):0.2, (3,9):0.3, (4,7):0.4}

Be aware that converting objects between Q and Python representations
can be time-consuming. For example, a joint pmf is implemented in Q as a
tree of one-dimensional real arrays, but is exposed to Python as a
dictionary.


Q compiler implementation
----------------------------

The Q compiler is written in Java and JavaCC. In brief, it consists of
four packages:

-  Package parser contains JavaCC-generated code.
-  Package tree contains a class for every node of the parse tree.
-  Package compiler constructs an Engine object that encapsulates each Q
   source file. This object does not take into account that it will
   later be referred as C++ code. So it could, in principle, be used to
   generate other code. For example, an interactive Q source debugger.
-  Package generator generates the C++ code.


Generated C++
----------------

The generated C++ code consists of roughly 2,000 lines of boilerplate,
followed by a section of generated code for each Q source.

The boilerplate contains, in essence, a very large number of simple
constructs. Here are some underlying concepts:

-  A list of allocated memory blocks is created as memory is allocated
   in ``qmalloc``. When control returns to Python, memory blocks
   referenced in global variables are flagged, and all remaining blocks
   are freed.

-  Sampling functions are implemented by ``Accumulator`` objects. An
   accumulator accepts value-probability pairs, and constructs a pmf.

For each Q source, a struct ``_enginename_object`` serves as the engine
object exposed to Python. The struct ``QObject`` contains the part all
engine objects have in common. This includes the members required for
memory management. Functions such as ``binomial``, which perform memory
allocation, must be passed a ``QObject`` instance. Functions such as
``sqrt`` do not require this additional argument.
